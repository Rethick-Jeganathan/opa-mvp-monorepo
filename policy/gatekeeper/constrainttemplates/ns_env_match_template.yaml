apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: nsenvmatch
spec:
  crd:
    spec:
      names:
        kind: NsEnvMatch
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package nsenvmatch

        # Normalize external_data result item to fields
        get_key(r) = k {
          r.key == k
        } else = k {
          r[0] == k
        }

        get_value(r) = v {
          r.value == v
        } else = v {
          r[1] == v
        }

        get_error(r) = e {
          r.error == e
        } else = e {
          r[2] == e
        } else = "" {
          # default if not present
          true
        }

        # Require that Namespace label `env` matches external mapping from provider
        violation[{"msg": msg}] {
          input.review.kind.kind == "Namespace"
          name := input.review.object.metadata.name

          # call the provider with the namespace name as key
          results := external_data({"provider": "ns-env-provider", "keys": [name]})

          some i
          r := results[i]
          get_key(r) == name
          want := get_value(r)                  # expected env from provider
          err  := get_error(r)

          err == ""
          want != ""

          provided := input.review.object.metadata.labels.env
          provided != want

          msg := sprintf("namespace %q env label %q does not match external mapping %q", [name, provided, want])
        }

         # Fail-close if the provider call fails or returns no mapping
         violation[{"msg": msg}] {
           input.review.kind.kind == "Namespace"
           name := input.review.object.metadata.name
           results := external_data({"provider": "ns-env-provider", "keys": [name]})

           # No entry for the namespace in results
           not any_result_for_name(results, name)
           msg := sprintf("external data missing or unreachable for namespace %q", [name])
         }

         # helper: check if any result exists for the given name
         any_result_for_name(results, name) {
           some i
           get_key(results[i]) == name
         }
